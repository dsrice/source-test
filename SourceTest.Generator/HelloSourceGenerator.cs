using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SourceTest.Generator
{
    [Generator]
    public class HelloSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Generate the attribute first
            context.RegisterPostInitializationOutput(ctx =>
            {
                var attributeSource = @"using System;

namespace SourceTest.Generator
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class GenerateHelloAttribute : Attribute
    {
    }
}
";
                ctx.AddSource("GenerateHelloAttribute.g.cs", SourceText.From(attributeSource, Encoding.UTF8));
            });

            // Create a pipeline to find classes with our attribute
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null);

            // Generate code for each class
            context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(source, spc));
        }

        static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDeclaration &&
                   classDeclaration.AttributeLists.Count > 0 &&
                   classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword);
        }

        static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

            if (symbol is null)
                return null;

            // Check if the class has our attribute
            foreach (var attribute in symbol.GetAttributes())
            {
                if (attribute.AttributeClass?.Name == "GenerateHelloAttribute" ||
                    attribute.AttributeClass?.ToDisplayString() == "SourceTest.Generator.GenerateHelloAttribute")
                {
                    return symbol;
                }
            }

            return null;
        }

        static void Execute(INamedTypeSymbol? classSymbol, SourceProductionContext context)
        {
            if (classSymbol is null)
                return;

            var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : classSymbol.ContainingNamespace.ToDisplayString();
            var className = classSymbol.Name;

            var source = new StringBuilder();

            if (!string.IsNullOrEmpty(namespaceName))
            {
                source.AppendLine($"namespace {namespaceName}");
                source.AppendLine("{");
            }

            source.AppendLine($"    public partial class {className}");
            source.AppendLine("    {");
            source.AppendLine($"        public string SayHello()");
            source.AppendLine("        {");
            source.AppendLine($"            return \"Hello from {className}! This method was generated by Source Generator.\";");
            source.AppendLine("        }");
            source.AppendLine();
            source.AppendLine("        public string GetGeneratedInfo()");
            source.AppendLine("        {");
            source.AppendLine("            return \"This partial class was generated at compile time.\";");
            source.AppendLine("        }");
            source.AppendLine("    }");

            if (!string.IsNullOrEmpty(namespaceName))
            {
                source.AppendLine("}");
            }

            context.AddSource($"{className}.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        }
    }
}
